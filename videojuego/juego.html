<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/bootstrap.min.css">
    <title>Juego</title>
    <style>
        .altura {
            height: 60px;
            /* Ajustado para que quepa mejor en pantalla */
        }

        .bordered {
            border: 2px solid rgb(200, 200, 200);
            /* Borde más sutil */
        }

        .backgrounded {
            background-color: gainsboro;
        }

        .player {
            background-image: url('./imagenes/Personaje-test1.png');
            background-size: contain;
            /* Contain es mejor para que no se corte la imagen */
            background-repeat: no-repeat;
            background-position: center;
            background-color: darkgray;
            /* Color de fondo para distinguirlo */
        }
    </style>
</head>

<body>
    <div class="container" id="grid">

    </div>
    <textarea id="transcripcion" rows="5" cols="50" readonly></textarea>
    <button id="iniciar">Iniciar Reconocimiento</button>
    <button id="detener">Detener Reconocimiento</button>
    <audio id="moveSound" src="../sonidos/quack.mp3" preload="auto"></audio>

</body>
<script>
    // --- PARTE 1: GENERACIÓN DEL GRID (CON IDs ÚNICOS) ---
    window.addEventListener('load', function () {
        const gridContainer = document.getElementById("grid");
        const gridHeight = 10; // Número de filas
        const gridWidth = 12;  // Número de columnas

        for (let i = 0; i < gridHeight; i++) {
            let fila = document.createElement("div");
            fila.className = 'row altura';
            // No necesitamos ID en la fila, pero lo dejamos por si lo usas después
            fila.id = 'y' + i;

            for (let o = 0; o < gridWidth; o++) {
                let columna = document.createElement("div");
                columna.className = 'col-1 backgrounded bordered';

                // ---- CAMBIO IMPORTANTE: ID ÚNICO ----
                // Creamos un ID como "cell-fila-columna", ej: "cell-0-0"
                columna.id = `cell-${i}-${o}`;

                fila.appendChild(columna);
            }
            gridContainer.appendChild(fila);
        }

        // Posición inicial del jugador
        let startingCell = document.getElementById('cell-0-0');
        // Usamos classList.add() que es más seguro que sobreescribir className
        startingCell.classList.add('player');
    });

    // --- PARTE 2: LÓGICA DE MOVIMIENTO ---
    document.addEventListener('keydown', function (event) {
        // Usamos querySelector que nos devuelve el PRIMER elemento con la clase '.player'
        // Es más directo y no tenemos que usar el índice [0]
        const player = document.querySelector(".player");

        // Si no existe un jugador, no hacemos nada.
        if (!player) {
            return;
        }

        // Obtenemos las coordenadas actuales desde el ID del jugador
        // "cell-y-x" -> ["cell", "y", "x"]
        const coords = player.id.split('-');
        let y = parseInt(coords[1]);
        let x = parseInt(coords[2]);

        // Guardamos las coordenadas futuras
        let nextY = y;
        let nextX = x;

        switch (event.key) {
            case 'ArrowUp':
                nextY = y - 1;
                break;
            case 'ArrowDown':
                nextY = y + 1;
                break;
            case 'ArrowLeft':
                nextX = x - 1;
                break;
            case 'ArrowRight':
                nextX = x + 1;
                break;
            case 'w':
                nextY = y - 1;
                break;
            case 's':
                nextY = y + 1;
                break;
            case 'a':
                nextX = x - 1;
                break;
            case 'd':
                nextX = x + 1;
                break;
            case 'W':
                nextY = y - 1;
                break;
            case 'S':
                nextY = y + 1;
                break;
            case 'A':
                nextX = x - 1;
                break;
            case 'D':
                nextX = x + 1;
                break;
            default:
                return; // Si no es una flecha, no hacemos nada
        }

        // Verificamos que no se salga de los límites del grid
        const gridHeight = 10;
        const gridWidth = 12;
        if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {

            // Construimos el ID de la siguiente celda
            const nextCellId = `cell-${nextY}-${nextX}`;
            const nextCell = document.getElementById(nextCellId);

            if (nextCell) {
                // Movemos la clase "player"
                player.classList.remove('player');
                nextCell.classList.add('player');

                // Reproducir sonido de movimiento
                const moveSound = document.getElementById('moveSound');
                if (moveSound) {
                    moveSound.currentTime = 0; // Reinicia el sonido si se pulsa rápido
                    moveSound.play();
                }
            }
        }
    });

    const textarea = document.getElementById('transcripcion');
    const iniciarBtn = document.getElementById('iniciar');
    const detenerBtn = document.getElementById('detener'); // Agregamos un botón para detener

    // Comprobar si el navegador es compatible con la Web Speech API
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert("Tu navegador no soporta la API de reconocimiento de voz.");
    } else {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();

        // Configuración
        recognition.lang = 'es-ES';
        recognition.continuous = true; // Permite escuchar de forma continua
        recognition.interimResults = true; // Habilita los resultados provisionales

        // Manejar el clic para iniciar el reconocimiento
        iniciarBtn.onclick = () => {
            recognition.start();
            textarea.value = " ";
            iniciarBtn.disabled = true;
            detenerBtn.disabled = false;
        };

        // Manejar el clic para detener el reconocimiento
        detenerBtn.onclick = () => {
            recognition.stop();
            iniciarBtn.disabled = false;
            detenerBtn.disabled = true;
        };

        // Evento cuando se recibe un resultado (final o provisional)
        recognition.onresult = (event) => {
            let finalTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript;
                if (event.results[i].isFinal) {
                    finalTranscript += transcript;
                }
            }
            // Solo actualizamos el textarea con el resultado final
            if (finalTranscript) {
                // Usamos un simple += para concatenar el texto
                textarea.value += finalTranscript + ' ';
            }
        };

        // Evento si ocurre un error
        recognition.onerror = (event) => {
            textarea.value = "Error al reconocer voz: " + event.error;
            iniciarBtn.disabled = false;
            detenerBtn.disabled = true;
        };

        // Evento cuando el reconocimiento se detiene
        recognition.onend = () => {
            if (!iniciarBtn.disabled) {
                //textarea.value = "Reconocimiento finalizado. Haz clic en Iniciar para comenzar de nuevo.";
            }
        };

        // Evento cuando se recibe un resultado (final o provisional)
        recognition.onresult = (event) => {
            let finalTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript.trim().toLowerCase();
                if (event.results[i].isFinal) {
                    finalTranscript += transcript;
                }
            }

            if (finalTranscript) {
                textarea.value += finalTranscript + ' ';

                // Detectar comandos 
                if (finalTranscript.includes("arriba")) {
                    simularTecla("ArrowUp");
                } else if (finalTranscript.includes("abajo")) {
                    simularTecla("ArrowDown");
                } else if (finalTranscript.includes("izquierda")) {
                    simularTecla("ArrowLeft");
                } else if (finalTranscript.includes("derecha")) {
                    simularTecla("ArrowRight");
                }
            }
        };

        // Reiniciar automáticamente si se detiene
        recognition.onend = () => {
            recognition.start();
        };

        // Manejo de errores
        recognition.onerror = (event) => {
            console.error("Error en reconocimiento de voz:", event.error);
            textarea.value += "\n[Error: " + event.error + "]";
        };
    }

        

    // Función para simular el evento de teclado
    function simularTecla(tecla) {
        const evento = new KeyboardEvent("keydown", { key: tecla });
        document.dispatchEvent(evento);
    }

</script>

</html>