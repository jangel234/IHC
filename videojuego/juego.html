<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/bootstrap.min.css">
    <title>Juego</title>
    <style>
        .altura {
            height: 60px;
            /* Ajustado para que quepa mejor en pantalla */
        }

        body {
            display: block;
            justify-items: center;
            background-image: url('./imagenes/el-bueno.png');
            /* ← tu imagen de fondo */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        #grid {
            margin: 0;
            /* background: lightcoral; */
            /* ← tu imagen de fondo */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .bordered {
            border: 2px solid rgb(200, 200, 200);
            /* Borde más sutil */
        }

        .backgrounded,
        .bordered {
            border: none;
            background: transparent;
        }

        .player {
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            background-image: url('./imagenes/pato.png');
        }

    /* Direcciones */
        .player.down {
            background-image: url('./imagenes/patoabj.png');
        }

        .player.up {
            background-image: url('./imagenes/patoarriba.png');
        }

        .player.left {
            background-image: url('./imagenes/patoizq.png');
        }

        .player.right { 
            background-image: url('./imagenes/pato.png');
        }


        /* Migaja (crumb) visual */
        .crumb {
            width: 22px;
            height: 22px;
            background: radial-gradient(circle at 30% 30%, #fff4b8 0%, #f2c94c 40%, #c58b00 100%);
            border-radius: 50%;
            margin: 4px auto;
            /* centra en la celda */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>

<body>
    <div id="hud" style="margin:8px 0;font-weight:600; font-size: 40px; display: flex; justify-content: center;">Puntos: &nbsp; 
        <span id="score">0</span>
    </div>
    <div class="container" id="grid">
    </div>
    <textarea id="transcripcion" rows="5" cols="50" readonly style="display: none;"></textarea>
    <div style="display: flex; justify-content: center;">
        
        <button id="iniciar">Jugar con voz!</button>
        <button id="detener">Jugar sin voz</button>
    </div>
    <audio autoplay loop>
        <source src="../sonidos/musica-fondo.mp3" type="audio/mpeg">
    </audio>
    <audio id="moveSound" src="../sonidos/Cuackcorto.mp3" preload="auto"></audio>
</body>
<script>
    // --- PARTE 1: GENERACIÓN DEL GRID (CON IDs ÚNICOS) ---     
    window.addEventListener('load', function () {
        const gridContainer = document.getElementById("grid");
        const gridHeight = 10; // Número de filas         
        const gridWidth = 12;  // Número de columnas         
        for (let i = 0; i < gridHeight; i++) {
            let fila = document.createElement("div");
            fila.className = 'row altura';
            // No necesitamos ID en la fila, pero lo dejamos por si lo usas después             
            fila.id = 'y' + i;
            for (let o = 0; o < gridWidth; o++) {
                let columna = document.createElement("div");
                columna.className = 'col-1 backgrounded bordered';
                // ---- CAMBIO IMPORTANTE: ID ÚNICO ----                 
                // Creamos un ID como "cell-fila-columna", ej: "cell-0-0"                 
                columna.id = `cell-${i}-${o}`;
                fila.appendChild(columna);
            }
            gridContainer.appendChild(fila);
        }
        // Posición inicial del jugador         
        let startingCell = document.getElementById('cell-5-6');
        // Usamos classList.add() que es más seguro que sobreescribir className         
        startingCell.classList.add('player');
    });

    // --- PARTE 2: LÓGICA DE MOVIMIENTO ---     
    document.addEventListener('keydown', function (event) {
    const player = document.querySelector(".player");
    if (!player) return;

    const coords = player.id.split('-');
    let y = parseInt(coords[1]);
    let x = parseInt(coords[2]);
    let nextY = y;
    let nextX = x;
    let directionClass = '';

    switch (event.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
            nextY = y - 1;
            directionClass = 'up';
            break;
        case 'ArrowDown':
        case 's':
        case 'S':
            nextY = y + 1;
            directionClass = 'down';
            break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
            nextX = x - 1;
            directionClass = 'left';
            break;
        case 'ArrowRight':
        case 'd':
        case 'D':
            nextX = x + 1;
            directionClass = 'right';
            break;
        default:
            return;
    }

    // Mantiene los límites del tablero
    const gridHeight = 10;
    const gridWidth = 12;
    if (nextX >= 0 && nextX < gridWidth && nextY >= 0 && nextY < gridHeight) {
        const nextCellId = `cell-${nextY}-${nextX}`;
        const nextCell = document.getElementById(nextCellId);

        if (nextCell) {
            // Mover jugador
            player.className = player.className.replace(/\bplayer\b.*$/, ''); // Limpia clases antiguas
            nextCell.classList.add('player', directionClass);

            // Reproducir sonido
            const moveSound = document.getElementById('moveSound');
            if (moveSound) {
                moveSound.currentTime = 0;
                moveSound.play();
            }
        }
    } else {
        // Si no se mueve porque está al borde, igual actualiza la dirección visual
        player.classList.remove('up', 'down', 'left', 'right');
        player.classList.add(directionClass);
    }
});


    // --- PARTE 3: MIGAJAS (LÓGICA ESTÁTICA) ---
    const gridHeight = 10;
    const gridWidth = 12;
    const maxCrumbs = 1; // Límite de 20 migajas
    
    let crumbs = []; // array de {y, x, element}
    const crumbSound = new Audio('../sonidos/clear-combo.mp3');
    const scoreEl = document.getElementById('score');
    let score = 0;

    // Crear una migaja DOM dentro de una celda
    function placeCrumbAt(y, x) {
        const cell = document.getElementById(`cell-${y}-${x}`);
        if (!cell) return null;
        const frag = document.createElement('div');
        frag.className = 'crumb';
        cell.appendChild(frag);
        return frag;
    }

    // Quitar el DOM de una migaja
    function removeCrumbDOMObj(obj) {
        if (!obj) return;
        const el = obj.element;
        if (el && el.parentElement) el.parentElement.removeChild(el);
    }

    // Comprueba si ya existe una migaja en la posición (y,x)
    function crumbAt(y, x) {
        return crumbs.find(c => c.y === y && c.x === x);
    }

    // [MODIFICADA] Hace aparecer una migaja en un lugar aleatorio y vacío
    function spawnCrumb() {
        if (crumbs.length >= maxCrumbs) return; // No exceder el límite

        let y, x, attempts = 0;
        const maxAttempts = 50; // Para evitar un bucle infinito si el tablero está lleno

        // Buscar la posición del jugador para no aparecer encima de él
        const player = document.querySelector('.player');
        let py = -1, px = -1;
        if (player) {
            const pcoords = player.id.split('-');
            py = parseInt(pcoords[1]);
            px = parseInt(pcoords[2]);
        }

        // Buscar una celda aleatoria que esté vacía (sin migaja y sin jugador)
        do {
            y = Math.floor(Math.random() * gridHeight);
            x = Math.floor(Math.random() * gridWidth);
            attempts++;
        } while (
            (crumbAt(y, x) || (y === py && x === px)) && attempts < maxAttempts
        );

        // Si se encontró un lugar, poner la migaja
        if (attempts < maxAttempts) {
            const el = placeCrumbAt(y, x);
            crumbs.push({ y, x, element: el });
        }
    }


    // Lógica para comer una migaja
    function eatCrumbAtIndex(i) {
        const c = crumbs[i];
        try {
            crumbSound.currentTime = 0;
            crumbSound.play();
        } catch (e) {
            // ignore autoplay errors
        }
        score += 1;
        scoreEl.textContent = score;

        // Quitar la migaja del DOM y del array
        removeCrumbDOMObj(c);
        crumbs.splice(i, 1);

        // [CAMBIO] Llamar a spawnCrumb() directamente para reponerla
        spawnCrumb();
    }

    // Inicia el juego llenando el tablero
    function startCrumbLoop() {
        // Spawn inicial de las 20 migajas con pequeños delays
        for (let i = 0; i < maxCrumbs; i++) {
            setTimeout(spawnCrumb, i * 900 + Math.random() * 200);
        }
    }

    // Cuando el jugador se mueve, comprobar si ha entrado en la celda con alguna migaja
    document.addEventListener('keydown', function () {
        if (crumbs.length === 0) return;
        const player = document.querySelector('.player');
        if (!player) return;

        const coords = player.id.split('-');
        const py = parseInt(coords[1]);
        const px = parseInt(coords[2]);

        // Iteramos al revés para poder eliminar sin problemas
        for (let i = crumbs.length - 1; i >= 0; i--) {
            const c = crumbs[i];
            if (py === c.y && px === c.x) {
                eatCrumbAtIndex(i);
            }
        }
    });

    // Empezar bucle de migajas automáticamente cuando cargue la página
    window.addEventListener('load', function () {
        // Dejamos un pequeño retraso para que el grid y el jugador estén listos
        setTimeout(startCrumbLoop, 600);
    });

    //const textarea = document.getElementById('transcripcion');
    const iniciarBtn = document.getElementById('iniciar');
    const detenerBtn = document.getElementById('detener'); // Agregamos un botón para detener     

    // Comprobar si el navegador es compatible con la Web Speech API     
    if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert("Tu navegador no soporta la API de reconocimiento de voz.");
    } else {
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        // Configuración         
        recognition.lang = 'es-ES';
        recognition.continuous = true; // Permite escuchar de forma continua         
        recognition.interimResults = true; // Habilita los resultados provisionales         

        // Manejar el clic para iniciar el reconocimiento         
        iniciarBtn.onclick = () => {
            recognition.start();
            //textarea.value = " ";
            iniciarBtn.disabled = true;
            detenerBtn.disabled = false;
        };

        // Manejar el clic para detener el reconocimiento         
        detenerBtn.onclick = () => {
            recognition.stop();
            iniciarBtn.disabled = false;
            detenerBtn.disabled = true;
        };

        // Evento cuando se recibe un resultado (final o provisional)
        recognition.onresult = (event) => {
            let finalTranscript = '';
            for (let i = event.resultIndex; i < event.results.length; i++) {
                const transcript = event.results[i][0].transcript.trim().toLowerCase();
                if (event.results[i].isFinal) {
                    finalTranscript += transcript;
                }
            }

            if (finalTranscript) {
                //textarea.value += finalTranscript + ' ';

                // Detectar comandos 
                if (finalTranscript.includes("arriba")) {
                    simularTecla("ArrowUp");
                } else if (finalTranscript.includes("abajo")) {
                    simularTecla("ArrowDown");
                } else if (finalTranscript.includes("izquierda")) {
                    simularTecla("ArrowLeft");
                } else if (finalTranscript.includes("derecha")) {
                    simularTecla("ArrowRight");
                }
            }
        };

        // Reiniciar automáticamente si se detiene
        recognition.onend = () => {
            recognition.start();
        };

        // Evento si ocurre un error         
        recognition.onerror = (event) => {
            alert("Error al reconocer voz: " + event.error);
            iniciarBtn.disabled = false;
            detenerBtn.disabled = true;
        };
    }



    // Función para simular el evento de teclado
    function simularTecla(tecla) {
        const evento = new KeyboardEvent("keydown", { key: tecla });
        document.dispatchEvent(evento);
    }



    // Evento cuando el reconocimiento se detiene         
    recognition.onend = () => {
        if (!iniciarBtn.disabled) {
            alert("Reconocimiento finalizado. Haz clic en Iniciar para comenzar de nuevo!.");
        }
    }; 
</script>

</html>